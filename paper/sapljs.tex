\section{A \JS based implementation for  \Sapl}
\label{sapljs:sec:sapljs}
Section \ref{sapljs:sec:motivation} motivated our choice for implementing the
\Sapl interpreter in the browser using \JS. Compared to \Java, this language 
provides several features that offer opportunities for a more efficient 
implementation. First of all, the fact that \JS is a \emph{dynamic} language allows both functions and function calls to be generated at run-time, using the 
built-in functions \texttt{eval} and \texttt{apply}, respectively. Second, the 
fact that \JS is a dynamically \emph{typed} language allows the creation of 
heterogeneous arrays. Therefore, rather than building an interpreter, we have 
chosen to build a compiler/interpreter hybrid that exploits the features 
mentioned above.

As mentioned in section \ref{sapljs:sec:sapl}, the original \Sapl interpreter 
provides no special constructs for algebraic data types. The \texttt{select}
keyword is used as a hint to the compiler that allows constructor based case selection to be optimized, but it is also possible to represent constructors 
as functions that act as case selectors themselves. As it turns out, the
translation to \JS can be made more efficient by representing constructors in a
special way. Therefore, it is no longer possible to represent constructors as ordinary functions, and special constructs for constructors have been added to
the language. Furthermore, the \texttt{select} keyword is now obligatory when doing constructor based case analysis.

For the following \Sapl constructs we must describe how they are translated to 
\JS:
\begin{itemize}
	\item constants, such as booleans, integers, real numbers, and strings;
    \item identifiers, such as variable and function names;
    \item let constructs;
	\item function definitions;
	\item function applications;
	\item constructor definitions;
	\item select statements;
	\item if statements;
	\item built-in functions, such as \texttt{add}, \texttt{eq}, etc.
\end{itemize}

\subsubsection{Constants}
Constants do not have to be transformed. They have the same representation in
\Sapl and \JS.

\subsubsection{Identifiers}
Identifiers in \Sapl and \JS share the same namespace. Therefore, identifiers do
not have to be transformed either.

\subsubsection{\textsf{Let} constructs} 
\texttt{Let} constructs are translated differently depending on whether they
are cyclic or not. Non-cyclic lets in \Sapl can be translated to \texttt{var}
declarations in \JS, as follows: 
\begin{CleanCode}
let x = b in e
\end{CleanCode}
is translated to:
\begin{CleanCode}
var x = tb; te
\end{CleanCode}
where \texttt{tb} and \texttt{te} are the result of the translation of 
\texttt{b} and \texttt{e}, respectively.

Due to \JS's support for closures, cyclic lets can be translated from \Sapl to
\JS in a straightforward manner. The idea is to take any occurences of 
\texttt{x} in \texttt{b} and replace them with:
\begin{CleanCode}
function () { return b; }
\end{CleanCode}
This construction relies on the fact that \JS combines a function with any free
variables used by that function to form a closure.

\subsubsection{Function definitions} 
Due to \JS's support for higher-order functions, function definitions can be
translated from \Sapl to \JS in a straightforward manner:
\begin{CleanCode}
f x1 ... xn = body
\end{CleanCode}
is translated to:
\begin{CleanCode}
function f(x1, ..., xn) { tbody }
\end{CleanCode}
where \texttt{tbody} is the result of the translation of \texttt{body}.

\subsubsection{Function applications} 
Every \Sapl expression is a function application. Due to \JS's non-eager 
evaluation semantics, function applications cannot be translated from \Sapl to 
\JS directly. Instead, unevaluated expressions (or \emph{thunks}) in \Sapl are translated to arrays in \JS:
\begin{CleanCode}
f x0 .. xn 
\end{CleanCode}
is translated to:
\begin{CleanCode}
[tf, [tx0, ..., txn]]
\end{CleanCode}
where \texttt{tf} and \texttt{txi} are the result of the translation of 
\texttt{f} and \texttt{xi}, respectively.

\subsubsection{Constructor definitions} 
Constructor definitions in \Sapl are translated to arrays in \JS, in such a way 
that they can be used in a \texttt{select} construct to select the right case. 
A \Sapl type definition containing constructors is translated as follows:
\begin{CleanCode}
:: typename = ... | Ck a0 ... an | ...
\end{CleanCode}
is transformed to:
\begin{CleanCode}
... function Ck(x0, ..., xn) { return [k, [`Ck', tx0, ..., txn]]; } ...
\end{CleanCode}
where \texttt{k} is a positive integer, corresponding to the position of the 
constructor in the original type definition, and \texttt{txi} is the result of
the translation of \texttt{xi}. The name of the constructor, \texttt{`Ck'}, is 
put into the result for debugging purposes.

\subsubsection{\textsf{select} statements} 
A \texttt{select} statement in \Sapl is translated to a \texttt{switch} 
statement in \JS, as follows:
\begin{CleanCode}
select f (\x0 ... xn = b) ..
\end{CleanCode}
is translated to:
\begin{CleanCode}
var _tmp = Sapl.eval(tf);
switch(_tmp[0]) {
	case 0: var x0 = _tmp[1][1], ..., xn = _tmp[1][n+1];
	        tb;
            break;
	...
};
\end{CleanCode}
where \texttt{tf} and \texttt{tb} are the result of the translation of
\texttt{f} and \texttt{b}, respectively. The

Evaluating the first argument of a \texttt{select} statement yields an array representing a constructor (see above). The first argument in this array 
represents the position of the constructor in its type definition, and is used 
to select the right case in the definition. The parameters of the $\lambda$-
expression for each case are bound to the corresponding arguments of the constructor in the \texttt{var} declaration (see also examples).

\subsubsection{\textsf{if} statements} 
An \texttt{if} statement in \Sapl is translated to the conditional operator in 
\JS, as follows:
\begin{CleanCode}
if p t f
\end{CleanCode}
is translated to:
\begin{CleanCode}
Sapl.eval(tp) ? tt : tf;
\end{CleanCode}
where \texttt{tp}, \texttt{tt}, \texttt{tf} are the result of the translation of
\texttt{p}, \texttt{t}, \texttt{f}, respectively. This translation works because
booleans in \Sapl and \JS have the same representation.

\subsubsection{Built-in Functions}
\Sapl defines several built-in functions for arithmetic and logical operations.
As an example, the \texttt{add} function is defined as follows:
\begin{CleanCode}
function add(x, y) { return Sapl.eval(x) + Sapl.eval(y); }
\end{CleanCode}
Unlike user-defined functions, built-in functions such as \texttt{add} have
strict evaluation semantics. To guarantee that they are in normal form when the 
function is called, the function \texttt{Sapl.eval} is applied to its arguments
(see section \ref{eval}).

\subsection{Examples}
The following definitions in \Sapl:
\begin{CleanCode}
:: list = Nil | Cons x xs	
ones = let os = Cons 1 os in os
fac n = if (eq n 0) 1 (mult n (fac (sub n 1)))
sum xxs = select xxs 0 (\x xs = add x (sum xs))
\end{CleanCode}
%
are translated to the following definitions in \JS:
\begin{CleanCode}
function Nil() { return [0, ['nil']]; }
function Cons(x, xs) { return [1, ['Cons', x, xs]]; }

function ones() { var os = Cons(1, function() { return os; }); return os; }

function fac(n) {
    return (eq(n,0)) ? 1 : [mult, [n, [fac, [[sub, [n, 1]]]]]];
}

function sum(as) {
	var _tmp = Sapl.eval(as);
	switch (_tmp[0]) {
		case 0: return 0;
		case 1: var x = _tmp[1][1], xs = _tmp[1][2]; 
				return [add, [x, [sum, [xs]]]];
	};
}

\end{CleanCode}
The examples show that the translation is straightforward and preserves the
structure of the original definitions.

\subsection{The \texttt{eval} function}
\label{eval}
The generated \JS functions cannot be executed directly, because they contain unevaluated thunks.
The \textsf{eval} function is used to evaluate these thunks (turn them into head-normal-form).
\textsf{eval} must do a case analysis on the expression it is offered.
It's action depends on the type of  this expression:

\begin{itemize}
\item Primitive values (int, real, boolean, string) are immediately returned. They are already in normal form.
\item Constructor arrays  are also immediately returned. They are already in normal form too.
\item A thunk \texttt{[f,[as]]} is turned into a function call \texttt{f(as)}.
The result of this call must be written back into the original array, because there may be more than
one reference to the same array because of sharing. 
\texttt{eval} is applied recursively to the result.
In case the result is a primitive value the array must be resized to length 1.
In \JS an array re-size operation does not change the location of the array.  
Of course, the call is only made if there are enough arguments. 
If there are too few arguments the thunk itself is returned (it is in normal form already).
If there are too many arguments, a new thunk
is build using the result of the call and the remainder of the arguments.
Also here \texttt{eval} is applied to the result. 
\item Boxed values \texttt{[v]} are un-boxed (v is returned, only primitive values can be boxed).
\item Curried applications \texttt{[[a,[as]],[bs]]} are turned into  \texttt{[a,[as++bs]]}, and
\texttt{eval} is applied recursively to the result.
\end{itemize}

\subsection{Normal Forms}
Above we described a straightforward compilation scheme from \Sapl to \JS, 
where expressions (thunks) are transformed to arrays.
%The only optimization we already made is replacing arithmetic expressions directly by there \JS counterparts 
%and thereby forcing the evaluation of there arguments. 
%In this way we may impose unwanted eager sub-expressions into a program. 
%If a programmer does not want this he or she should use an indirection via an own-made auxiliary function.
The \texttt{eval} function is used to turn a thunk into a \JS expression and to reduce it to head-normal-form.
%The \texttt{eval} function has to do a case analysis on the structure of the thunk expression.
For a function application  we measured that a direct \JS call is more than 10 times faster 
than making the same call using the 
\texttt{eval} function on the thunk representing the call. This overhead is significant. 
Fortunately, in many cases we can do an analysis at compile time and replace a call to \texttt{eval} for a thunk by the corresponding hard coded \JS.
This transformation replaces:
\begin{CleanCode}
Sapl.eval([f,[a1,..,an])
\end{CleanCode}
by:
\begin{CleanCode}
f(a1,..,an)
\end{CleanCode}
This may only be done if \texttt{f} is a known function (thus not a variable) and the number of applied arguments matches the
arity of \texttt{f}.
This can be done at every place where an explicit call to \textsf{eval} is done:
\begin{itemize}
\item The first argument of a \texttt{select} or \texttt{if};
\item The arguments of an arithmetic operation;
\item At every place where a resulting expression occurs within a \JS function (expressions after a \texttt{return}).
For these expressions  \texttt{eval} is always called immediately after they are returned.
\end{itemize}
Another optimization we made is inlining arithmetic operations directly into the code.
Using these optimizations the translations of \texttt{sum} and \texttt{fac} now become:
\begin{CleanCode}
function fac(n){
	return (Sapl.eval(n) == 0) ? 1 : Sapl.eval(n) * fac(Sapl.eval(n)-1);
}

function sum(as){
	var _ys = Sapl.eval(as);
	switch(_ys[0]){
		case 0: return 0;
		case 1: var x = _ys[1][1], xs = _ys[1][2]; 
		        return Sapl.eval(x)+sum(xs);
	}
}
\end{CleanCode}
In Section \ref{sapljs:sec:benchmarks} we show that these optimizations often result in 
a significant speed-up.

%\textit{<<start of Eddy's part>>\\
%A major source of overhead in the current implementation are the calls to the
%evaluator function {\texttt eval}, generated by applying the translation scheme
%$T$ to built-in operators. To illustrate this, consider the following definition
%of the fibonacci function, $fib$, in SAPL:
%
%\begin{CleanCode}
%fib = \ n -> n < 2 ? 1 : fib (n - 1) + fib (n - 2)
%\end{CleanCode}
%
%Applying $T$ to this expression yields the following code in \JS:
%
%\begin{CleanCode}
%var fib = function (n) {
%    return n < 2 ? 1 : eval([fib, [eval(n) - 1]]) + eval([fib, [eval(n) - 2]]);
%}
%\end{CleanCode}
%
%Using this definition, the number of calls to {\texttt eval} is proportional to
%$O(n^2)$, which is prohibitive even for small values of $n$.
%
%
%In the above example, two thunks are created for the recursive applications of
%$fib$, only to be immediately reduced again to normal form because their value
%is required by the operator $+$. It should be obvious that these applications
%might as well be performed immediately in this case, thus avoiding both the
%construction of the thunks and the outer two calls to {\texttt eval}. In
%general, $T$ generates a call to {\texttt eval} when an expression is required
%to be in normal form (for instance because it is used as an operand to a
%built-in operator). However, if it is known at compile time that an expression
%already is in normal form, the call to {\texttt eval} is unnecessary, and can
%be avoided.
%
%To take advantage of this observation, a new translation scheme, $S$, is
%introduced, which is equivalent to $T$, except for the added restriction that
%expressions generated by $S$ should always be in normal form. To adhere to this
%restriction, the rule for function applications has to be rewritten as follows:
%
%\begin{equation*}
%S \llbracket E_1 \: E_2 \: \ldots \: E_n \rrbracket \equiv
%\begin{cases}
%[T \llbracket E_1 \rrbracket, [T \llbracket E_2 \rrbracket,
%                               \ldots,
%                               S \llbracket E_n \rrbracket]] &
%        \text{if $n \le m$} \\
%T \llbracket E_1 \rrbracket(T \llbracket E_2 \rrbracket,
%                            \ldots,
%                            T \llbracket E_n \rrbracket) &
%        \text{if $n = m$} \\
%eval([ T \llbracket E_1 \rrbracket(T \llbracket E_2 \rrbracket,
%                                   \ldots,
%                                   T \llbracket E_n \rrbracket),
%                        [T \llbracket E_{m+1} \rrbracket,
%                         \ldots,
%                         T \llbracket E_n \rrbracket]]) &
%        \text{otherwise (if $n > m$)}
%\end{cases}
%\end{equation*}
%where $m$ is the arity of $E_1$.
%
%The above rule assumes that $E_1$ is a lambda abstraction, and that the arity of
%$E_1$ is known. The possibility that $E_1$ is actually an identifier introduces
%the need for a symbol table, which allows names to be resolved to their
%corresponding bindings. Furthermore, it is impossible to determine the arity of
%a function at compile time in the following to the cases:
%
%\begin{enumerate}
%\item The function was passed as an argument to the current function
%\item The function was returned as a the result of a function application
%\end{enumerate}
%
%In both cases, a call to {\texttt eval} is still necessary. The former case
%occurs when $n > m$, and is already handled in the above rule. The latter case
%occurs when $E_1$ is resolved to be a local identifier, and is handled by the
%following additional rule:
%
%\[ S \llbracket E_1 \: E_2 \: \ldots \: E_n \rrbracket \equiv
%   eval(T \llbracket E_1 \: E_2 \: \ldots \: E_n \rrbracket) \]
%
%Note how the behavior of $S$ closely mimics that of {\texttt eval}. Indeed,
%from a conceptual point of view, $S$ performs the call to {\texttt eval} at
%compile time, rather than run time. This allows the rule in $T$ for translating
%built-in operators to be rewritten as follows:
%
%\begin{align*}
%T \llbracket op_1 \: E_1 \rrbracket &
%        \equiv op_1 \: S \llbracket E_1 \rrbracket \\
%T \llbracket E_1 \: op_2 \: E_2 \rrbracket &
%        \equiv S \llbracket E_1 \rrbracket \: op_2 \:
%               S \llbracket E_2 \rrbracket \\
%T \llbracket E_1 \: ? \: E_2 \: : \: \rrbracket &
%        \equiv S \llbracket E_1 \rrbracket \: ? \:
%               S \llbracket E_2 \rrbracket \: : \:
%               S \llbracket E_3 \rrbracket 
%\end{align*}
%
%Observe that this new rule does not generate any calls to {\texttt eval}, and
%that $S$ only generates calls to {\texttt eval} if the arity of a function
%cannot be determined at compile time.
%
%In the above discussion, it was silently assumed that the result of a function
%application is always in head normal form. To meet this requirement, however,
%the rules for translating let(rec)-expressions and functions have to be
%rewritten such that the expression returned is translated using $S$, rather than
%$T$.
%
%\begin{verbatim}
%T <<f as>> = [f,[as]]
%T <<C as>> = 
%\end{verbatim}}
