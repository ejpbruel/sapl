\section{Related Work}\label{sapljs:sec:related}
%\vspace{-0.3cm}
Client-side processing for Internet applications is a subject that has drawn much attention in the last years with the advent of \textsf{Ajax} based
applications.% \cite{AJAX}.

Earlier approaches using \JS as a client-side platform for the execution of functional programming languages are \textsf{Hop} \cite{HOP1,HOP2},
\textsf{Links} \cite{LINKS1} and \textsf{Curry}  \cite{CURRY}. 

\textsf{Hop} is a dedicated web programming language with a \textsf{HTML}-like syntax build on top of \textsf{Scheme}. 
%In \textsf{Hop} it is  possible to specify a complete web application without the (direct) use of \textsf{JavaScript}. 
It uses two compilers, one for compiling the server-side program and one for compiling the client-side part. 
The client-side part is only used for executing the user interface. 
The application essentially runs on the client and may call services on the server.
Syntactic constructions are used
for indicating client and server part code.
In \cite{HOP2} it is shown that a reasonably good performance for client-side functions in \textsf{Hop} can be obtained. 

\textsf{Links} \cite{LINKS1} and its extension \textsf{Formlets}  is a functional language-based web programming language. 
\textsf{Links} compiles to \textsf{JavaScript} for rendering \textsf{HTML} pages, and \textsf{SQL} to communicate with a back-end database.
Client-server communication is implemented using \textsf{Ajax} technology, 
like this is done in the \iTask system. 

 \textsf{Curry} offers a much more restricted approach:
 only a very restricted subset of the functional-logic language \textsf{Curry} 
is translated to \textsf{JavaScript} to handle client-side verification code fragments only.

A more recent approach is the \textsf{Flapjax} language \cite{FLAPJAX}, 
an implementation of functional reactive programming in \textsf{JavaScript}.
\textsf{Flapjax} can be used either as a programming language, 
compiling to \JS, or as a \JS library. 
Entire applications can be developed in \textsf{Flapjax}.  
\textsf{Flapjax} automatically tracks dependencies and propagates updates along 
dataflows, allowing for a declarative style of programming.

An approach to compile \Haskell to \JS is \textsf{YCR2JS} \cite{YHC2JS} that compiles \textsf{YHC Core} to \JS, 
comparable to our approach compiling \Sapl to \JS. Unfortunately, we could not find any performance figures for this implementation.

Another, more recent approach, for compiling \Haskell to \JS is \textsf{HS2JS} \cite{HS2JS}, which integrates a \JS backend into the \textsf{GHC} compiler. 
Again, we were not able to find any performance figures for this implementation.


