\section{Related Work}\label{sapljs:sec:related}
Client-side processing for Internet applications is a subject that has drawn much attention in the last years with the advent of \textsf{Ajax} based
applications \cite{AJAX}.

Earlier approaches using \JS as a client-side platform for the execution of a functional programming languages are \textsf{Hop} \cite{HOP1,HOP2},
Links \cite{LINKS1}and \textsf{Curry}  \cite{CURRY}. 
\textsf{Hop} is a dedicated web programming language and its syntax is \textsf{HTML}-like. 
In \textsf{Hop} it is  possible to specify a complete web application without the (direct) use of \textsf{JavaScript}. 
\textsf{Hop} uses two compilers, one for compiling the server-side program and one for compiling the client-side part. 
The client-side part is only used for executing the user interface. 
The application essentially runs on the client and may call services on the server, which is typical for \textsf{AJAX} based applications. 
\textsf{Hop} uses syntactic constructions for indicating client and server part code. It is build on top of the Scheme programming language. 
In \cite{HOP2} it is shown that a reasonably good performance for client-side functions in \textsf{Hop} can be obtained. 

\textsf{Links} \cite{LINKS1} and its extension \textsf{Formlets}  is a functional language-based web programming language. \textsf{Links} compiles to \textsf{JavaScript} for rendering \textsf{HTML} pages, and SQL to communicate with a back-end database. A \textsf{Links} program stores its session state at the client side. In a \textsf{Links} program, the keywords \texttt{client} and \texttt{server} force a top-level function to be executed at the client or server respectively. In \textsf{Links}, processes can be spawned and these processes can communicate via message passing. Client-server communication is implemented using \textsf{Ajax} technology, like we do in the \iTask system. 
%In the \textsf{iData} and \textsf{iTask} toolkits, forms are generated generically for every data type, whereas in \textsf{Links} and \textsf{Formlets} these need to be coded by the programmer. 

 \textsf{Curry} offers a much more restricted approach:
 only a very restricted subset of the functional-logic \textsf{Curry} is translated to \textsf{JavaScript} to handle client-side verification code fragments only.

A more recent approach is the \textsf{Flapjax} language \cite{FLAPJAX}, an implementation of functional reactive programming in \textsf{JavaScript}, with features comparable to those of \textsf{Hop}. \textsf{Flapjax} can be used either as a programming language, compiling to \JS, or as a \JS library. 
Entire applications can be developed in the \textsf{Flapjax} language.  \textsf{Flapjax} automatically tracks dependencies and propagates updates along 
dataflows, allowing for a declarative style of programming.

An approach to compile \Haskell to \JS is \textsf{YCR2JS}\cite{YHC2JS} which compiles \textsf{YHC Core} to \JS, 
which is comparable to our approach compiling \Sapl to \JS. Unfortunately, we were not able to find any performance figures for this implementation.

Another, more recent approach, for compiling \Haskell to \JS is \textsf{HS2JS} \cite{HS2JS}, which integrates a \JS backend into the \textsf{GHC} compiler. 
Again, we were not able to find any performance figures for this implementation.


